---
title: "template_microshades_taxabarplot"
author: "Madi"
date: "2023-05-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(qiime2R)
library(tidyverse)
library(cowplot)
library(magrittr)
library(viridis)
library(microshades)
library(phyloseq)
```

**Functions**
```{r}
## phyloseq input file prep (bc phyloseq is really nit-picky)
## metadata prep 
## make sure that you change the 'read' functions depending on whether you
## have a 'tsv' or a 'csv' 
metadata_prep <- function(metadata_fp) {
  tmpMeta <- read_tsv(metadata_fp, n_max = 2)
  mycols <- colnames(tmpMeta)
  metadata <- read_tsv(metadata_fp, skip = 2, col_names = mycols)
  names(metadata)[names(metadata) == '#SampleID'] <- 'sampleid'
  metadata <- as.data.frame(metadata)
  rownames(metadata) <- metadata$sampleid
  return(metadata)
}

## otu table prep with missing samples 
## assumes that you're reading in a 'tsv' file 
otu_phyloseq_prep <- function(otu_fp, missing_samples){
  otu_table <- read_tsv(file = otu_fp)
  otu_table %>% 
    gather(-asv, key = sample, value = count) %>% 
    filter(sample %in% missing_sample) %>% 
    spread(sample, count) -> otu_missing
  names(otu_missing)[names(otu_missing) == 'asv'] <- ' '
  otu_missing <- as.matrix(otu_missing)
  class(otu_missing) <- "numeric"
  return(otu_missing)
}

## tax table prep with missing samples 
## assumes that its a 'qza' file from qiime2
tax_table_prep <- function(taxonomy_fp, wanted_asvs){
  tax_table <- read_qza(taxonomy_fp)$data 
  tax_table %>% 
    parse_taxonomy() %>% 
    as_tibble(rownames = 'asv') %>%
    filter(asv %in% wanted_asvs) -> tax_missing
  names(tax_missing)[names(tax_missing) == 'asv'] <- ' '
  return(tax_missing)
}

## generating color palettes based on the phyloseq object you generated
## generate pseq like normal since there's already a nice function for it 
## just returns the color_objs_GP for you, you'll need to extract the mdf/cdf for the next function 
mdf_cdf_gp <- function(pseq, tax_table, tax_rank, tax_subgroup){
  pseq %>% 
  tax_glom(tax_subgroup) %>% 
    phyloseq::transform_sample_counts(function(x) {
     x/sum(x)
      }) %>% 
    psmelt() %>% 
  filter(Abundance > 0) -> mdf_prep
  phylum_table <- tax_glom(pseq, taxrank=tax_rank, ) %>% otu_table()
  phyla.otunames <- rownames(phylum_table)
  phylums <- tax_table(as.matrix(tax_table))[phyla.otunames,tax_rank]
  sorted_phylums <- phylums[order(rowSums(phylum_table), decreasing=T)]
## can take ranked phylums out if you don't have issues with top abund. phylums being repeated
## ranked_phylums <- sort(unique(sorted_phylums[40:1]))
  color_objs_GP <- create_color_dfs(mdf_prep,
                                 subgroup_level = tax_subgroup,
                                 selected_groups = sorted_phylums[5:1])
  return(color_objs_GP)
}

##functions for taxa barplot construction via microshades 
## should be able to edit this like ggplot to add title and axes specs. 
tax_barplot <- function(mdf_GP, cdf_GP){
  barplot <- plot_microshades(mdf_GP, cdf_GP)
  barplot_1 <- barplot + scale_y_continuous(labels = scales::percent, expand = expansion(0)) +
    theme_bw(base_size = 18) +
    theme(legend.position = "none") +
    theme(axis.text.x = element_blank())
  return(barplot_1)
}

tax_barplot_legend <- function(mdf_GP, cdf_GP, tax_subgroup){
  GP_legend <-custom_legend(mdf_GP, cdf_GP, 
                          legend_key_size=unit(0.4, "cm"),
                          legend_text_size=15, subgroup_level=tax_subgroup)
  return(GP_legend)
}

## putting entire taxa barplot together
whole_tax_barplot <- function(tax_barplot, tax_barplot_legend){
  tax_all <- plot_grid(tax_barplot, tax_barplot_legend,  rel_widths = c(1, .25),
                       align = 'tblr',
                       axis = 'tblr')
  return(tax_all)
}
```

**Overall Function Order for Microshades Taxa Barplot Construction**
```{r}
pseq_meta <- metadata_prep(metadata_fp)
pseq_otu <- otu_phyloseq_prep(otu_fp, missing_samples)
pseq_tax <- tax_table_prep(taxonomy_fp, wanted_asvs)

pseq <- phyloseq(otu_table(pseq_otu, taxa_are_rows = TRUE),
                 tax_table(as.matrix(pseq_tax)),
                 sample_data(pseq_meta))

mdf_and_cdf <- mdf_cdf_gp(pseq, pseq_tax, tax_rank, tax_subgroup)

mdf_GP <- mdf_and_cdf$mdf
cdf_GP <- mdf_and_cdf$cdf

main_barplot <- tax_barplot(mdf_GP, cdf_GP)
legend <- tax_barplot_legend(mdf_GP, cdf_GP, tax_subgroup)

whole_barplot <- whole_tax_barplot(main_barplot, legend)
```

**Functions for otu and tax table prep when you don't have missing samples**
use of function outputs is like so:
meta <- metadata_prep(metadata_fp)
otu <- otu_prep(otu_fp)
tax <- tax_prep(tax_fp, otu)

pseq <- phyloseq(otu_table(otu, taxa_are_rows = TRUE),
                tax_table(as.matrix(tax)),
                sample_data(meta))
the rest is the same from here! 
```{r}
## this assumes that you're reading in a qiime2 'qza' file
## this also doesn't filter out anything for you 
## but you usually shouldn't need the filtration steps
otu_prep <- function(otu_fp){
  otu_table <- read_qza(file = otu_fp)$data
  return(otu_table)
}

## this assumes that your input is a 'qza' file 
tax_prep <- function(tax_fp, otu_table){
  tax_table <- read_qza(file = tax_fp)$data %>% 
    parse_taxonomy()
  tax_table %>% 
    filter(rownames(tax_table) %in% rownames(otu_table)) -> tax_table
  return(tax_table)
}
```

**Putting all microshades functions into a giant function to create a mini-pipeline**
```{r}
microshades_tax_barplot <- function(meta_fp, otu_fp, tax_fp,
                                    tax_rank, tax_subgroup,
                                    title_text, y_text){
  pseq_meta <- metadata_prep(meta_fp)
  pseq_otu <- otu_prep(otu_fp)
  pseq_tax <- tax_prep(tax_fp, pseq_otu)
  pseq <- phyloseq(otu_table(pseq_otu, taxa_are_rows = TRUE),
                 tax_table(as.matrix(pseq_tax)),
                 sample_data(pseq_meta))
  mdf_and_cdf <- mdf_cdf_gp(pseq, pseq_tax, tax_rank, tax_subgroup)
  mdf_GP <- mdf_and_cdf$mdf
  cdf_GP <- mdf_and_cdf$cdf
  main_barplot <- tax_barplot(mdf_GP, cdf_GP) +
    ggtitle(title_text) +
    ylab(y_text)
  legend <- tax_barplot_legend(mdf_GP, cdf_GP, tax_subgroup)
  whole_barplot <- whole_tax_barplot(main_barplot, legend)
  return(whole_barplot)
}
```

**Testing my mini-pipeline with neonatal gut microbiome data**
oh my god it worked!!
```{r, fig.width=25,fig.height=15}
## inputs
MG_metadata_fp <- '~/neonatal-gut-microbiome/MG R outputs/MG_metadata.csv'
otu_table_fp <- '~/neonatal-gut-microbiome/tax-filtered-MG.qza'
tax_table_fp <- '~/neonatal-gut-microbiome/taxonomy-MG.qza'
MG_tax_rank <- "Phylum"
MG_tax_subgroup <- "Family"
MG_title <- 'Neonatal Mouse Microbiome Development'
MG_y <- 'Relative Abundance'

## barplot function
microshades_tax_barplot(MG_metadata_fp, otu_table_fp, tax_table_fp,
                        MG_tax_rank, MG_tax_subgroup,
                        MG_title, MG_y)
```


